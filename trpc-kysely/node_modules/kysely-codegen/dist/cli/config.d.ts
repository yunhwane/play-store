import { z } from 'zod';
import type { LogLevel, Overrides, RuntimeEnumsStyle, Serializer } from '../generator';
import { ArrayExpressionNode, ExtendsClauseNode, GenericExpressionNode, IdentifierNode, InferClauseNode, LiteralNode, Logger, MappedTypeNode, ObjectExpressionNode, RawExpressionNode, UnionExpressionNode } from '../generator';
import type { DateParser, NumericParser } from '../introspector';
import { DatabaseMetadata, IntrospectorDialect } from '../introspector';
export type Config = {
    camelCase?: boolean;
    dateParser?: DateParser;
    defaultSchemas?: string[];
    dialect?: DialectName;
    domains?: boolean;
    envFile?: string;
    excludePattern?: string | null;
    includePattern?: string | null;
    logger?: Logger;
    logLevel?: LogLevel;
    numericParser?: NumericParser;
    outFile?: string | null;
    overrides?: Overrides;
    partitions?: boolean;
    print?: boolean;
    runtimeEnums?: boolean | RuntimeEnumsStyle;
    serializer?: Serializer;
    singularize?: boolean | Record<string, string>;
    skipAutogeneratedFileComment?: boolean;
    typeOnlyImports?: boolean;
    url?: string;
    verify?: boolean;
};
export type DialectName = z.infer<typeof dialectNameSchema>;
export declare const dialectNameSchema: z.ZodEnum<["bun-sqlite", "kysely-bun-sqlite", "libsql", "mssql", "mysql", "postgres", "sqlite", "worker-bun-sqlite"]>;
export declare const configSchema: z.ZodObject<{
    camelCase: z.ZodOptional<z.ZodBoolean>;
    dateParser: z.ZodOptional<z.ZodEnum<["string", "timestamp"]>>;
    defaultSchemas: z.ZodOptional<z.ZodArray<z.ZodString, "many">>;
    dialect: z.ZodOptional<z.ZodEnum<["bun-sqlite", "kysely-bun-sqlite", "libsql", "mssql", "mysql", "postgres", "sqlite", "worker-bun-sqlite"]>>;
    domains: z.ZodOptional<z.ZodBoolean>;
    envFile: z.ZodOptional<z.ZodString>;
    excludePattern: z.ZodOptional<z.ZodNullable<z.ZodString>>;
    includePattern: z.ZodOptional<z.ZodNullable<z.ZodString>>;
    logger: z.ZodOptional<z.ZodType<Logger, z.ZodTypeDef, Logger>>;
    logLevel: z.ZodOptional<z.ZodEnum<["silent", "error", "warn", "info", "debug"]>>;
    numericParser: z.ZodOptional<z.ZodEnum<["number", "number-or-string", "string"]>>;
    outFile: z.ZodOptional<z.ZodNullable<z.ZodString>>;
    overrides: z.ZodOptional<z.ZodOptional<z.ZodObject<{
        columns: z.ZodOptional<z.ZodRecord<z.ZodString, z.ZodUnion<[z.ZodType<ArrayExpressionNode, z.ZodTypeDef, ArrayExpressionNode>, z.ZodType<ExtendsClauseNode, z.ZodTypeDef, ExtendsClauseNode>, z.ZodType<GenericExpressionNode, z.ZodTypeDef, GenericExpressionNode>, z.ZodType<IdentifierNode, z.ZodTypeDef, IdentifierNode>, z.ZodType<InferClauseNode, z.ZodTypeDef, InferClauseNode>, z.ZodType<LiteralNode<string | number>, z.ZodTypeDef, LiteralNode<string | number>>, z.ZodType<MappedTypeNode, z.ZodTypeDef, MappedTypeNode>, z.ZodType<ObjectExpressionNode, z.ZodTypeDef, ObjectExpressionNode>, z.ZodType<RawExpressionNode, z.ZodTypeDef, RawExpressionNode>, z.ZodType<UnionExpressionNode, z.ZodTypeDef, UnionExpressionNode>, z.ZodString]>>>;
    }, "strip", z.ZodTypeAny, {
        columns?: Record<string, string | ArrayExpressionNode | ExtendsClauseNode | GenericExpressionNode | IdentifierNode | InferClauseNode | MappedTypeNode | ObjectExpressionNode | RawExpressionNode | UnionExpressionNode | LiteralNode<string | number>> | undefined;
    }, {
        columns?: Record<string, string | ArrayExpressionNode | ExtendsClauseNode | GenericExpressionNode | IdentifierNode | InferClauseNode | MappedTypeNode | ObjectExpressionNode | RawExpressionNode | UnionExpressionNode | LiteralNode<string | number>> | undefined;
    }>>>;
    partitions: z.ZodOptional<z.ZodBoolean>;
    print: z.ZodOptional<z.ZodBoolean>;
    runtimeEnums: z.ZodOptional<z.ZodUnion<[z.ZodBoolean, z.ZodEnum<["pascal-case", "screaming-snake-case"]>]>>;
    serializer: z.ZodOptional<z.ZodObject<{
        serializeFile: z.ZodFunction<z.ZodTuple<[z.ZodType<DatabaseMetadata, z.ZodTypeDef, DatabaseMetadata>, z.ZodType<IntrospectorDialect, z.ZodTypeDef, IntrospectorDialect>, z.ZodOptional<z.ZodObject<{
            camelCase: z.ZodOptional<z.ZodBoolean>;
            defaultSchemas: z.ZodOptional<z.ZodArray<z.ZodString, "many">>;
            overrides: z.ZodOptional<z.ZodOptional<z.ZodObject<{
                columns: z.ZodOptional<z.ZodRecord<z.ZodString, z.ZodUnion<[z.ZodType<ArrayExpressionNode, z.ZodTypeDef, ArrayExpressionNode>, z.ZodType<ExtendsClauseNode, z.ZodTypeDef, ExtendsClauseNode>, z.ZodType<GenericExpressionNode, z.ZodTypeDef, GenericExpressionNode>, z.ZodType<IdentifierNode, z.ZodTypeDef, IdentifierNode>, z.ZodType<InferClauseNode, z.ZodTypeDef, InferClauseNode>, z.ZodType<LiteralNode<string | number>, z.ZodTypeDef, LiteralNode<string | number>>, z.ZodType<MappedTypeNode, z.ZodTypeDef, MappedTypeNode>, z.ZodType<ObjectExpressionNode, z.ZodTypeDef, ObjectExpressionNode>, z.ZodType<RawExpressionNode, z.ZodTypeDef, RawExpressionNode>, z.ZodType<UnionExpressionNode, z.ZodTypeDef, UnionExpressionNode>, z.ZodString]>>>;
            }, "strip", z.ZodTypeAny, {
                columns?: Record<string, string | ArrayExpressionNode | ExtendsClauseNode | GenericExpressionNode | IdentifierNode | InferClauseNode | MappedTypeNode | ObjectExpressionNode | RawExpressionNode | UnionExpressionNode | LiteralNode<string | number>> | undefined;
            }, {
                columns?: Record<string, string | ArrayExpressionNode | ExtendsClauseNode | GenericExpressionNode | IdentifierNode | InferClauseNode | MappedTypeNode | ObjectExpressionNode | RawExpressionNode | UnionExpressionNode | LiteralNode<string | number>> | undefined;
            }>>>;
        }, "strip", z.ZodTypeAny, {
            defaultSchemas?: string[] | undefined;
            camelCase?: boolean | undefined;
            overrides?: {
                columns?: Record<string, string | ArrayExpressionNode | ExtendsClauseNode | GenericExpressionNode | IdentifierNode | InferClauseNode | MappedTypeNode | ObjectExpressionNode | RawExpressionNode | UnionExpressionNode | LiteralNode<string | number>> | undefined;
            } | undefined;
        }, {
            defaultSchemas?: string[] | undefined;
            camelCase?: boolean | undefined;
            overrides?: {
                columns?: Record<string, string | ArrayExpressionNode | ExtendsClauseNode | GenericExpressionNode | IdentifierNode | InferClauseNode | MappedTypeNode | ObjectExpressionNode | RawExpressionNode | UnionExpressionNode | LiteralNode<string | number>> | undefined;
            } | undefined;
        }>>], null>, z.ZodString>;
    }, "strip", z.ZodTypeAny, {
        serializeFile: (args_0: DatabaseMetadata, args_1: IntrospectorDialect, args_2: {
            defaultSchemas?: string[] | undefined;
            camelCase?: boolean | undefined;
            overrides?: {
                columns?: Record<string, string | ArrayExpressionNode | ExtendsClauseNode | GenericExpressionNode | IdentifierNode | InferClauseNode | MappedTypeNode | ObjectExpressionNode | RawExpressionNode | UnionExpressionNode | LiteralNode<string | number>> | undefined;
            } | undefined;
        } | undefined) => string;
    }, {
        serializeFile: (args_0: DatabaseMetadata, args_1: IntrospectorDialect, args_2: {
            defaultSchemas?: string[] | undefined;
            camelCase?: boolean | undefined;
            overrides?: {
                columns?: Record<string, string | ArrayExpressionNode | ExtendsClauseNode | GenericExpressionNode | IdentifierNode | InferClauseNode | MappedTypeNode | ObjectExpressionNode | RawExpressionNode | UnionExpressionNode | LiteralNode<string | number>> | undefined;
            } | undefined;
        } | undefined) => string;
    }>>;
    singularize: z.ZodOptional<z.ZodUnion<[z.ZodBoolean, z.ZodRecord<z.ZodString, z.ZodString>]>>;
    skipAutogeneratedFileComment: z.ZodOptional<z.ZodBoolean>;
    typeOnlyImports: z.ZodOptional<z.ZodBoolean>;
    url: z.ZodOptional<z.ZodString>;
    verify: z.ZodOptional<z.ZodBoolean>;
}, "strip", z.ZodTypeAny, {
    url?: string | undefined;
    defaultSchemas?: string[] | undefined;
    domains?: boolean | undefined;
    partitions?: boolean | undefined;
    camelCase?: boolean | undefined;
    dateParser?: "string" | "timestamp" | undefined;
    dialect?: "kysely-bun-sqlite" | "bun-sqlite" | "libsql" | "mssql" | "mysql" | "postgres" | "sqlite" | "worker-bun-sqlite" | undefined;
    envFile?: string | undefined;
    excludePattern?: string | null | undefined;
    includePattern?: string | null | undefined;
    logger?: Logger | undefined;
    logLevel?: "error" | "debug" | "silent" | "warn" | "info" | undefined;
    numericParser?: "string" | "number" | "number-or-string" | undefined;
    outFile?: string | null | undefined;
    overrides?: {
        columns?: Record<string, string | ArrayExpressionNode | ExtendsClauseNode | GenericExpressionNode | IdentifierNode | InferClauseNode | MappedTypeNode | ObjectExpressionNode | RawExpressionNode | UnionExpressionNode | LiteralNode<string | number>> | undefined;
    } | undefined;
    print?: boolean | undefined;
    runtimeEnums?: boolean | "screaming-snake-case" | "pascal-case" | undefined;
    serializer?: {
        serializeFile: (args_0: DatabaseMetadata, args_1: IntrospectorDialect, args_2: {
            defaultSchemas?: string[] | undefined;
            camelCase?: boolean | undefined;
            overrides?: {
                columns?: Record<string, string | ArrayExpressionNode | ExtendsClauseNode | GenericExpressionNode | IdentifierNode | InferClauseNode | MappedTypeNode | ObjectExpressionNode | RawExpressionNode | UnionExpressionNode | LiteralNode<string | number>> | undefined;
            } | undefined;
        } | undefined) => string;
    } | undefined;
    singularize?: boolean | Record<string, string> | undefined;
    skipAutogeneratedFileComment?: boolean | undefined;
    typeOnlyImports?: boolean | undefined;
    verify?: boolean | undefined;
}, {
    url?: string | undefined;
    defaultSchemas?: string[] | undefined;
    domains?: boolean | undefined;
    partitions?: boolean | undefined;
    camelCase?: boolean | undefined;
    dateParser?: "string" | "timestamp" | undefined;
    dialect?: "kysely-bun-sqlite" | "bun-sqlite" | "libsql" | "mssql" | "mysql" | "postgres" | "sqlite" | "worker-bun-sqlite" | undefined;
    envFile?: string | undefined;
    excludePattern?: string | null | undefined;
    includePattern?: string | null | undefined;
    logger?: Logger | undefined;
    logLevel?: "error" | "debug" | "silent" | "warn" | "info" | undefined;
    numericParser?: "string" | "number" | "number-or-string" | undefined;
    outFile?: string | null | undefined;
    overrides?: {
        columns?: Record<string, string | ArrayExpressionNode | ExtendsClauseNode | GenericExpressionNode | IdentifierNode | InferClauseNode | MappedTypeNode | ObjectExpressionNode | RawExpressionNode | UnionExpressionNode | LiteralNode<string | number>> | undefined;
    } | undefined;
    print?: boolean | undefined;
    runtimeEnums?: boolean | "screaming-snake-case" | "pascal-case" | undefined;
    serializer?: {
        serializeFile: (args_0: DatabaseMetadata, args_1: IntrospectorDialect, args_2: {
            defaultSchemas?: string[] | undefined;
            camelCase?: boolean | undefined;
            overrides?: {
                columns?: Record<string, string | ArrayExpressionNode | ExtendsClauseNode | GenericExpressionNode | IdentifierNode | InferClauseNode | MappedTypeNode | ObjectExpressionNode | RawExpressionNode | UnionExpressionNode | LiteralNode<string | number>> | undefined;
            } | undefined;
        } | undefined) => string;
    } | undefined;
    singularize?: boolean | Record<string, string> | undefined;
    skipAutogeneratedFileComment?: boolean | undefined;
    typeOnlyImports?: boolean | undefined;
    verify?: boolean | undefined;
}>;
